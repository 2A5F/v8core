// <auto-generated>
// This code is generated by csbindgen.
// DON'T CHANGE THIS DIRECTLY.
// </auto-generated>
#pragma warning disable CS8500
#pragma warning disable CS8981
using System;
using System.Runtime.InteropServices;

namespace Coplt.V8Core.LowLevel.Gen
{
    internal static unsafe partial class NativeMethods
    {
        const string __DllName = "v8core";

        [DllImport(__DllName, EntryPoint = "coplt_v8core_get_root_vtable", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern RootVTable* coplt_v8core_get_root_vtable();


    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct RootVTable
    {
        public V8VTable* v8;
        public PlatformVTable* platform;
        public IsolateVTable* isolate;
        public HandleScopeVTable* handle_scope;
        public ContextVTable* context;
        public ContextScopeVTable* context_scope;
        public ScriptVTable* script;
        public ValueVTable* value;
        public StringVTable* @string;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct V8VTable
    {
        public delegate* unmanaged[Cdecl]<PlatformOpaque, void> initialize_platform;
        public delegate* unmanaged[Cdecl]<void> initialize;
        public delegate* unmanaged[Cdecl]<void> auto_ensures_init;
        public delegate* unmanaged[Cdecl]<bool> is_initialized;
        public delegate* unmanaged[Cdecl]<PlatformOpaque> current_platform;
        public delegate* unmanaged[Cdecl]<ByteSlice> version;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct ByteSlice
    {
        public byte* ptr;
        public nuint len;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct CharSlice
    {
        public ushort* ptr;
        public nuint len;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct CharSliceMut
    {
        public ushort* ptr;
        public nuint len;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct SharedPtrOpaque
    {
        public nuint Item1;
        public nuint Item2;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct PlatformOpaque
    {
        public SharedPtrOpaque Item1;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct PlatformVTable
    {
        public delegate* unmanaged[Cdecl]<PlatformOpaque, void> drop;
        public delegate* unmanaged[Cdecl]<PlatformOpaque, PlatformOpaque> clone;
        public delegate* unmanaged[Cdecl]<uint, bool, PlatformOpaque> ctor;
        public delegate* unmanaged[Cdecl]<bool, PlatformOpaque> ctor_single_threaded;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct IsolateOpaque
    {
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct OwnedIsolateOpaque
    {
        public nuint Item1;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct IsolateCreateParams
    {
        public delegate* unmanaged[Cdecl]<byte*, int*> counter_lookup_callback;
        public OptionBool allow_atomics_wait;
        public OptionBool only_terminate_in_safe_scope;
        [MarshalAs(UnmanagedType.U1)] public bool set_embedder_wrapper_type_info_offsets;
        public int embedder_wrapper_type_index;
        public int embedder_wrapper_object_index;
        [MarshalAs(UnmanagedType.U1)] public bool set_heap_limits;
        public nuint heap_limits_initial;
        public nuint heap_limits_max;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct IsolateVTable
    {
        public delegate* unmanaged[Cdecl]<OwnedIsolateOpaque, void> drop;
        public delegate* unmanaged[Cdecl]<IsolateCreateParams, OwnedIsolateOpaque> ctor;
        public delegate* unmanaged[Cdecl]<OwnedIsolateOpaque> ctor_default;
        public delegate* unmanaged[Cdecl]<OwnedIsolateOpaque*, IsolateOpaque*> deref;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct HandleScopeOpaque
    {
        public nuint Item1;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct HandleScopeVTable
    {
        public delegate* unmanaged[Cdecl]<OwnedIsolateOpaque*, HandleScopeOpaque> ctor_isolate;
        public delegate* unmanaged[Cdecl]<HandleScopeOpaque*, IsolateOpaque*> deref_to_isolate;
        public HandleScopeImplVTable* isolate;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct HandleScopeObject
    {
        public HandleScopeOpaque* ptr;
        public HandleScopeImplVTable* vt;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct HandleScopeImplVTable
    {
        public delegate* unmanaged[Cdecl]<HandleScopeOpaque, void> drop;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct LocalContextOpaque
    {
        public nuint Item1;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct ContextVTable
    {
        public delegate* unmanaged[Cdecl]<HandleScopeOpaque*, LocalContextOpaque> ctor;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct ContextScopeOpaque
    {
        public nuint Item1;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct ContextScopeVTable
    {
        public delegate* unmanaged[Cdecl]<HandleScopeOpaque*, LocalContextOpaque, ContextScopeOpaque> ctor_isolate;
        public ContextScopeImplVTable* isolate;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct ContextScopeImplVTable
    {
        public delegate* unmanaged[Cdecl]<ContextScopeOpaque, void> drop;
        public delegate* unmanaged[Cdecl]<ContextScopeOpaque*, IsolateOpaque*> deref_to_isolate;
        public delegate* unmanaged[Cdecl]<ContextScopeOpaque*, HandleScopeObject> deref_to_isolate_scope;
        public delegate* unmanaged[Cdecl]<ContextScopeOpaque*, HandleScopeObject> deref_to_context_scope;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct LocalScriptOpaque
    {
        public nuint Item1;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct ScriptVTable
    {
        public delegate* unmanaged[Cdecl]<HandleScopeOpaque*, LocalStringOpaque, LocalScriptOpaque*, bool> ctor_compile;
        public delegate* unmanaged[Cdecl]<LocalScriptOpaque, HandleScopeOpaque*, LocalValueOpaque*, bool> run;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct ValueOpaque
    {
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct LocalValueOpaque
    {
        public void* Item1;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct ValueVTable
    {
        public delegate* unmanaged[Cdecl]<LocalValueOpaque, ValueOpaque*> deref;
        public delegate* unmanaged[Cdecl]<ValueOpaque*, HandleScopeOpaque*, LocalStringOpaque> type_of;
        public delegate* unmanaged[Cdecl]<ValueOpaque*, bool> is_undefined;
        public delegate* unmanaged[Cdecl]<ValueOpaque*, bool> is_null;
        public delegate* unmanaged[Cdecl]<ValueOpaque*, bool> is_null_or_undefined;
        public delegate* unmanaged[Cdecl]<ValueOpaque*, bool> is_true;
        public delegate* unmanaged[Cdecl]<ValueOpaque*, bool> is_false;
        public delegate* unmanaged[Cdecl]<ValueOpaque*, bool> is_name;
        public delegate* unmanaged[Cdecl]<ValueOpaque*, bool> is_string;
        public delegate* unmanaged[Cdecl]<ValueOpaque*, bool> is_symbol;
        public delegate* unmanaged[Cdecl]<ValueOpaque*, HandleScopeOpaque*, LocalStringOpaque*, bool> to_string;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct LocalStringOpaque
    {
        public void* Item1;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct StringVTable
    {
        public delegate* unmanaged[Cdecl]<HandleScopeOpaque*, CharSlice*, LocalStringOpaque*, bool> ctor_utf16;
        public delegate* unmanaged[Cdecl]<LocalStringOpaque, nuint> len;
        public delegate* unmanaged[Cdecl]<LocalStringOpaque, IsolateOpaque*, CharSliceMut*, nuint, int, nuint> read_utf16;
    }


    internal enum OptionBool : byte
    {
        None = 255,
        False = 0,
        True = 1,
    }


}
    